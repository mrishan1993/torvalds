"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commonNft = void 0;
exports.commonNft = {
    transfer: "\n\timport NonFungibleToken from address\n\timport @nftContract from address\n\n\t// transfer @nftContract token with tokenId to given address\n\t//\n\ttransaction(tokenId: UInt64, to: Address) {\n\t\t\tlet token: @NonFungibleToken.NFT\n\t\t\tlet receiver: Capability<@nftPublicType>\n\n\t\t\tprepare(account: AuthAccount) {\n\t\t\t\t\tlet collection = account.borrow<&@nftStorageType>(from: @nftStoragePath)\n\t\t\t\t\t\t\t?? panic(\"could not borrow @nftContract collection from account\")\n\t\t\t\t\tself.token <- collection.withdraw(withdrawID: tokenId)\n\t\t\t\t\tself.receiver = getAccount(to).getCapability<@nftPublicType>(@nftPublicPath)\n\t\t\t}\n\n\t\t\texecute {\n\t\t\t\t\tlet receiver = self.receiver.borrow()\n\t\t\t\t\t\t\t?? panic(\"recipient @nftContract collection not initialized\")\n\t\t\t\t\treceiver.deposit(token: <- self.token)\n\t\t\t}\n\t}\n\t",
    burn: "\n\timport NonFungibleToken from address\n\timport @nftContract from address\n\n\t// Burn @nftContract on signer account by tokenId\n\t//\n\ttransaction(tokenId: UInt64) {\n\t\t\tprepare(account: AuthAccount) {\n\t\t\t\t\tlet collection = account.borrow<&@nftStorageType>(from: @nftStoragePath)\n\t\t\t\t\t\t\t?? panic(\"could not borrow @nftContract collection from account\")\n\t\t\t\t\tdestroy collection.withdraw(withdrawID: tokenId)\n\t\t\t}\n\t}\n",
    setupAccount: "\n\timport NonFungibleToken from address\n\timport @nftContract from address\n\n\t// Setup storage for @nftContract on signer account\n\t//\n\ttransaction {\n\t\t\tprepare(account: AuthAccount) {\n\t\t\t\t\tif account.borrow<&@nftStorageType>(from: @nftStoragePath) == nil {\n\t\t\t\t\t\t\tlet collection <- @nftContract.createEmptyCollection() as! @@nftStorageType\n\t\t\t\t\t\t\taccount.save(<-collection, to: @nftStoragePath)\n\t\t\t\t\t\t\taccount.link<@nftPublicType>(@nftPublicPath, target: @nftStoragePath)\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\t",
    check: "\n\timport NonFungibleToken from address\n\timport @nftContract from address\n\n\t// check @nftContract collection is available on given address\n\t//\n\tpub fun main(address: Address): Bool {\n\t\t\treturn getAccount(address)\n\t\t\t\t\t.getCapability<@nftPublicType>(@nftPublicPath)\n\t\t\t\t\t.check()\n\t}\n\t",
};
