"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorefrontRaribleNFT = void 0;
exports.StorefrontRaribleNFT = {
    sell_flow: "\nimport LicensedNFT from 0xLICENSEDNFT\n\nimport RaribleNFT from 0xRARIBLENFT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FlowToken from 0xFLOWTOKEN\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// Sell RaribleNFT token for FlowToken with NFTStorefront\n//\ntransaction(tokenId: UInt64, price: UFix64) {\n    let nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n        let nftProviderPath = /private/RaribleNFTProviderForNFTStorefront\n        if !acct.getCapability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath)!.check() {\n            acct.link<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath, target: RaribleNFT.collectionStoragePath)\n        }\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath)!\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        if acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {\n            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront\n            acct.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)\n            acct.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let royalties: [RaribleOrder.PaymentPart] = []\n        let extraCuts: [RaribleOrder.PaymentPart] = []\n\n        for royalty in self.nftProvider.borrow()!.getRoyalties(id: tokenId) {\n            royalties.append(RaribleOrder.PaymentPart(address: royalty.address, rate: royalty.fee))\n        }\n\n\n        RaribleOrder.addOrder(\n            storefront: self.storefront,\n            nftProvider: self.nftProvider,\n            nftType: Type<@RaribleNFT.NFT>(),\n            nftId: tokenId,\n            vaultPath: /public/flowTokenReceiver,\n            vaultType: Type<@FlowToken.Vault>(),\n            price: price,\n            extraCuts: extraCuts,\n            royalties: royalties\n        )\n    }\n}\n",
    sell_fusd: "\nimport LicensedNFT from 0xLICENSEDNFT\n\nimport RaribleNFT from 0xRARIBLENFT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FUSD from 0xFUSD\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// Sell RaribleNFT token for FUSD with NFTStorefront\n//\ntransaction(tokenId: UInt64, price: UFix64) {\n    let nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n        let nftProviderPath = /private/RaribleNFTProviderForNFTStorefront\n        if !acct.getCapability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath)!.check() {\n            acct.link<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath, target: RaribleNFT.collectionStoragePath)\n        }\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath)!\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        if acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {\n            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront\n            acct.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)\n            acct.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let royalties: [RaribleOrder.PaymentPart] = []\n        let extraCuts: [RaribleOrder.PaymentPart] = []\n\n        for royalty in self.nftProvider.borrow()!.getRoyalties(id: tokenId) {\n            royalties.append(RaribleOrder.PaymentPart(address: royalty.address, rate: royalty.fee))\n        }\n\n\n        RaribleOrder.addOrder(\n            storefront: self.storefront,\n            nftProvider: self.nftProvider,\n            nftType: Type<@RaribleNFT.NFT>(),\n            nftId: tokenId,\n            vaultPath: /public/fusdReceiver,\n            vaultType: Type<@FUSD.Vault>(),\n            price: price,\n            extraCuts: extraCuts,\n            royalties: royalties\n        )\n    }\n}\n",
    update_flow: "\nimport LicensedNFT from 0xLICENSEDNFT\n\nimport RaribleNFT from 0xRARIBLENFT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FlowToken from 0xFLOWTOKEN\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// Cancels order with [orderId], then open new order with same RaribleNFT token for FlowToken [price]\n//\ntransaction(orderId: UInt64, price: UFix64) {\n    let nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let orderAddress: Address\n\n    prepare(acct: AuthAccount) {\n        let nftProviderPath = /private/RaribleNFTProviderForNFTStorefront\n        if !acct.getCapability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath)!.check() {\n            acct.link<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath, target: RaribleNFT.collectionStoragePath)\n        }\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath)!\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n            ?? panic(\"No Offer with that ID in Storefront\")\n\n        self.orderAddress = acct.address\n    }\n\n    execute {\n        let royalties: [RaribleOrder.PaymentPart] = []\n        let extraCuts: [RaribleOrder.PaymentPart] = []\n        let details = self.listing.getDetails()\n        let tokenId = details.nftID\n\n        for royalty in self.nftProvider.borrow()!.getRoyalties(id: tokenId) {\n            royalties.append(RaribleOrder.PaymentPart(address: royalty.address, rate: royalty.fee))\n        }\n\n\n        RaribleOrder.removeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: self.orderAddress,\n            listing: self.listing,\n        )\n\n        RaribleOrder.addOrder(\n            storefront: self.storefront,\n            nftProvider: self.nftProvider,\n            nftType: details.nftType,\n            nftId: details.nftID,\n            vaultPath: /public/flowTokenReceiver,\n            vaultType: Type<@FlowToken.Vault>(),\n            price: price,\n            extraCuts: extraCuts,\n            royalties: royalties\n        )\n    }\n}\n",
    update_fusd: "\nimport LicensedNFT from 0xLICENSEDNFT\n\nimport RaribleNFT from 0xRARIBLENFT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FUSD from 0xFUSD\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// Cancels order with [orderId], then open new order with same RaribleNFT token for FUSD [price]\n//\ntransaction(orderId: UInt64, price: UFix64) {\n    let nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let orderAddress: Address\n\n    prepare(acct: AuthAccount) {\n        let nftProviderPath = /private/RaribleNFTProviderForNFTStorefront\n        if !acct.getCapability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath)!.check() {\n            acct.link<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath, target: RaribleNFT.collectionStoragePath)\n        }\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,LicensedNFT.CollectionPublic}>(nftProviderPath)!\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n            ?? panic(\"No Offer with that ID in Storefront\")\n\n        self.orderAddress = acct.address\n    }\n\n    execute {\n        let royalties: [RaribleOrder.PaymentPart] = []\n        let extraCuts: [RaribleOrder.PaymentPart] = []\n        let details = self.listing.getDetails()\n        let tokenId = details.nftID\n\n        for royalty in self.nftProvider.borrow()!.getRoyalties(id: tokenId) {\n            royalties.append(RaribleOrder.PaymentPart(address: royalty.address, rate: royalty.fee))\n        }\n\n\n        RaribleOrder.removeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: self.orderAddress,\n            listing: self.listing,\n        )\n\n        RaribleOrder.addOrder(\n            storefront: self.storefront,\n            nftProvider: self.nftProvider,\n            nftType: details.nftType,\n            nftId: details.nftID,\n            vaultPath: /public/fusdReceiver,\n            vaultType: Type<@FUSD.Vault>(),\n            price: price,\n            extraCuts: extraCuts,\n            royalties: royalties\n        )\n    }\n}\n",
    buy_flow: "\nimport RaribleNFT from 0xRARIBLENFT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FlowToken from 0xFLOWTOKEN\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\n\n// Buy RaribleNFT token for FlowToken with NFTStorefront\n//\ntransaction (orderId: UInt64, storefrontAddress: Address) {\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let paymentVault: @FungibleToken.Vault\n    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\n    let tokenReceiver: &{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}\n    let buyerAddress: Address\n\n    prepare(acct: AuthAccount) {\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability(NFTStorefront.StorefrontPublicPath)!\n            .borrow<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        let mainVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow FlowToken vault from acct storage\")\n        self.paymentVault <- mainVault.withdraw(amount: price)\n\n        if acct.borrow<&RaribleNFT.Collection>(from: RaribleNFT.collectionStoragePath) == nil {\n            let collection <- RaribleNFT.createEmptyCollection() as! @RaribleNFT.Collection\n            acct.save(<-collection, to: RaribleNFT.collectionStoragePath)\n            acct.link<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>(RaribleNFT.collectionPublicPath, target: RaribleNFT.collectionStoragePath)\n        }\n\n        self.tokenReceiver = acct.getCapability(RaribleNFT.collectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>()\n            ?? panic(\"Cannot borrow NFT collection receiver from acct\")\n\n        self.buyerAddress = acct.address\n    }\n\n    execute {\n        let item <- RaribleOrder.closeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: storefrontAddress,\n            listing: self.listing,\n            paymentVault: <- self.paymentVault,\n            buyerAddress: self.buyerAddress\n        )\n        self.tokenReceiver.deposit(token: <-item)\n    }\n}\n",
    buy_fusd: "\nimport RaribleNFT from 0xRARIBLENFT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FUSD from 0xFUSD\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\n\n// Buy RaribleNFT token for FUSD with NFTStorefront\n//\ntransaction (orderId: UInt64, storefrontAddress: Address) {\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let paymentVault: @FungibleToken.Vault\n    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\n    let tokenReceiver: &{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}\n    let buyerAddress: Address\n\n    prepare(acct: AuthAccount) {\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability(NFTStorefront.StorefrontPublicPath)!\n            .borrow<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        let mainVault = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from acct storage\")\n        self.paymentVault <- mainVault.withdraw(amount: price)\n\n        if acct.borrow<&RaribleNFT.Collection>(from: RaribleNFT.collectionStoragePath) == nil {\n            let collection <- RaribleNFT.createEmptyCollection() as! @RaribleNFT.Collection\n            acct.save(<-collection, to: RaribleNFT.collectionStoragePath)\n            acct.link<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>(RaribleNFT.collectionPublicPath, target: RaribleNFT.collectionStoragePath)\n        }\n\n        self.tokenReceiver = acct.getCapability(RaribleNFT.collectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>()\n            ?? panic(\"Cannot borrow NFT collection receiver from acct\")\n\n        self.buyerAddress = acct.address\n    }\n\n    execute {\n        let item <- RaribleOrder.closeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: storefrontAddress,\n            listing: self.listing,\n            paymentVault: <- self.paymentVault,\n            buyerAddress: self.buyerAddress\n        )\n        self.tokenReceiver.deposit(token: <-item)\n    }\n}\n",
};
