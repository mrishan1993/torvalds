"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorefrontTopShot = void 0;
exports.StorefrontTopShot = {
    sell_flow: "\nimport RaribleFee from 0xRARIBLEFEE\nimport TopShot from 0xTOPSHOT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FlowToken from 0xFLOWTOKEN\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// Sell TopShot token for FlowToken with NFTStorefront\n//\ntransaction(tokenId: UInt64, price: UFix64) {\n    let nftProvider: Capability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n        let nftProviderPath = /private/TopShotProviderForNFTStorefront\n        if !acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath)!.check() {\n            acct.link<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath, target: /storage/MomentCollection)\n        }\n\n        self.nftProvider = acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath)!\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        if acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {\n            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront\n            acct.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)\n            acct.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let royalties: [RaribleOrder.PaymentPart] = []\n        let extraCuts: [RaribleOrder.PaymentPart] = []\n\n\n        extraCuts.append(RaribleOrder.PaymentPart(address: 0xTOPSHOTFEE, rate: 0.05))\n\n        RaribleOrder.addOrder(\n            storefront: self.storefront,\n            nftProvider: self.nftProvider,\n            nftType: Type<@TopShot.NFT>(),\n            nftId: tokenId,\n            vaultPath: /public/flowTokenReceiver,\n            vaultType: Type<@FlowToken.Vault>(),\n            price: price,\n            extraCuts: extraCuts,\n            royalties: royalties\n        )\n    }\n}\n",
    sell_fusd: "\nimport RaribleFee from 0xRARIBLEFEE\nimport TopShot from 0xTOPSHOT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FUSD from 0xFUSD\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// Sell TopShot token for FUSD with NFTStorefront\n//\ntransaction(tokenId: UInt64, price: UFix64) {\n    let nftProvider: Capability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n        let nftProviderPath = /private/TopShotProviderForNFTStorefront\n        if !acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath)!.check() {\n            acct.link<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath, target: /storage/MomentCollection)\n        }\n\n        self.nftProvider = acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath)!\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        if acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {\n            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront\n            acct.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)\n            acct.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let royalties: [RaribleOrder.PaymentPart] = []\n        let extraCuts: [RaribleOrder.PaymentPart] = []\n\n\n        extraCuts.append(RaribleOrder.PaymentPart(address: 0xTOPSHOTFEE, rate: 0.05))\n\n        RaribleOrder.addOrder(\n            storefront: self.storefront,\n            nftProvider: self.nftProvider,\n            nftType: Type<@TopShot.NFT>(),\n            nftId: tokenId,\n            vaultPath: /public/fusdReceiver,\n            vaultType: Type<@FUSD.Vault>(),\n            price: price,\n            extraCuts: extraCuts,\n            royalties: royalties\n        )\n    }\n}\n",
    update_flow: "\nimport RaribleFee from 0xRARIBLEFEE\nimport TopShot from 0xTOPSHOT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FlowToken from 0xFLOWTOKEN\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// Cancels order with [orderId], then open new order with same TopShot token for FlowToken [price]\n//\ntransaction(orderId: UInt64, price: UFix64) {\n    let nftProvider: Capability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let orderAddress: Address\n\n    prepare(acct: AuthAccount) {\n        let nftProviderPath = /private/TopShotProviderForNFTStorefront\n        if !acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath)!.check() {\n            acct.link<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath, target: /storage/MomentCollection)\n        }\n\n        self.nftProvider = acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath)!\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n            ?? panic(\"No Offer with that ID in Storefront\")\n\n        self.orderAddress = acct.address\n    }\n\n    execute {\n        let royalties: [RaribleOrder.PaymentPart] = []\n        let extraCuts: [RaribleOrder.PaymentPart] = []\n        let details = self.listing.getDetails()\n        let tokenId = details.nftID\n\n\n        extraCuts.append(RaribleOrder.PaymentPart(address: 0xTOPSHOTFEE, rate: 0.05))\n\n        RaribleOrder.removeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: self.orderAddress,\n            listing: self.listing,\n        )\n\n        RaribleOrder.addOrder(\n            storefront: self.storefront,\n            nftProvider: self.nftProvider,\n            nftType: details.nftType,\n            nftId: details.nftID,\n            vaultPath: /public/flowTokenReceiver,\n            vaultType: Type<@FlowToken.Vault>(),\n            price: price,\n            extraCuts: extraCuts,\n            royalties: royalties\n        )\n    }\n}\n",
    update_fusd: "\nimport RaribleFee from 0xRARIBLEFEE\nimport TopShot from 0xTOPSHOT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FUSD from 0xFUSD\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// Cancels order with [orderId], then open new order with same TopShot token for FUSD [price]\n//\ntransaction(orderId: UInt64, price: UFix64) {\n    let nftProvider: Capability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let orderAddress: Address\n\n    prepare(acct: AuthAccount) {\n        let nftProviderPath = /private/TopShotProviderForNFTStorefront\n        if !acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath)!.check() {\n            acct.link<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath, target: /storage/MomentCollection)\n        }\n\n        self.nftProvider = acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftProviderPath)!\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n            ?? panic(\"No Offer with that ID in Storefront\")\n\n        self.orderAddress = acct.address\n    }\n\n    execute {\n        let royalties: [RaribleOrder.PaymentPart] = []\n        let extraCuts: [RaribleOrder.PaymentPart] = []\n        let details = self.listing.getDetails()\n        let tokenId = details.nftID\n\n\n        extraCuts.append(RaribleOrder.PaymentPart(address: 0xTOPSHOTFEE, rate: 0.05))\n\n        RaribleOrder.removeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: self.orderAddress,\n            listing: self.listing,\n        )\n\n        RaribleOrder.addOrder(\n            storefront: self.storefront,\n            nftProvider: self.nftProvider,\n            nftType: details.nftType,\n            nftId: details.nftID,\n            vaultPath: /public/fusdReceiver,\n            vaultType: Type<@FUSD.Vault>(),\n            price: price,\n            extraCuts: extraCuts,\n            royalties: royalties\n        )\n    }\n}\n",
    buy_flow: "\nimport TopShot from 0xTOPSHOT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FlowToken from 0xFLOWTOKEN\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\n\n// Buy TopShot token for FlowToken with NFTStorefront\n//\ntransaction (orderId: UInt64, storefrontAddress: Address) {\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let paymentVault: @FungibleToken.Vault\n    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\n    let tokenReceiver: &{TopShot.MomentCollectionPublic}\n    let buyerAddress: Address\n\n    prepare(acct: AuthAccount) {\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability(NFTStorefront.StorefrontPublicPath)!\n            .borrow<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        let mainVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow FlowToken vault from acct storage\")\n        self.paymentVault <- mainVault.withdraw(amount: price)\n\n        if acct.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {\n            let collection <- TopShot.createEmptyCollection() as! @TopShot.Collection\n            acct.save(<-collection, to: /storage/MomentCollection)\n            acct.link<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection, target: /storage/MomentCollection)\n        }\n\n        self.tokenReceiver = acct.getCapability(/public/MomentCollection)\n            .borrow<&{TopShot.MomentCollectionPublic}>()\n            ?? panic(\"Cannot borrow NFT collection receiver from acct\")\n\n        self.buyerAddress = acct.address\n    }\n\n    execute {\n        let item <- RaribleOrder.closeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: storefrontAddress,\n            listing: self.listing,\n            paymentVault: <- self.paymentVault,\n            buyerAddress: self.buyerAddress\n        )\n        self.tokenReceiver.deposit(token: <-item)\n    }\n}\n",
    buy_fusd: "\nimport TopShot from 0xTOPSHOT\nimport RaribleOrder from 0xRARIBLEORDER\nimport FUSD from 0xFUSD\nimport FungibleToken from 0xFUNGIBLETOKEN\nimport NFTStorefront from 0xNFTSTOREFRONT\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\n\n// Buy TopShot token for FUSD with NFTStorefront\n//\ntransaction (orderId: UInt64, storefrontAddress: Address) {\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let paymentVault: @FungibleToken.Vault\n    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\n    let tokenReceiver: &{TopShot.MomentCollectionPublic}\n    let buyerAddress: Address\n\n    prepare(acct: AuthAccount) {\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability(NFTStorefront.StorefrontPublicPath)!\n            .borrow<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        let mainVault = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from acct storage\")\n        self.paymentVault <- mainVault.withdraw(amount: price)\n\n        if acct.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {\n            let collection <- TopShot.createEmptyCollection() as! @TopShot.Collection\n            acct.save(<-collection, to: /storage/MomentCollection)\n            acct.link<&{TopShot.MomentCollectionPublic}>(/public/MomentCollection, target: /storage/MomentCollection)\n        }\n\n        self.tokenReceiver = acct.getCapability(/public/MomentCollection)\n            .borrow<&{TopShot.MomentCollectionPublic}>()\n            ?? panic(\"Cannot borrow NFT collection receiver from acct\")\n\n        self.buyerAddress = acct.address\n    }\n\n    execute {\n        let item <- RaribleOrder.closeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: storefrontAddress,\n            listing: self.listing,\n            paymentVault: <- self.paymentVault,\n            buyerAddress: self.buyerAddress\n        )\n        self.tokenReceiver.deposit(token: <-item)\n    }\n}\n",
};
