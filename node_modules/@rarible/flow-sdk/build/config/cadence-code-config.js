"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNftCodeConfig = exports.getFtCodeConfig = exports.orderCodeConfig = void 0;
var tslib_1 = require("tslib");
exports.orderCodeConfig = {
    TopShot: {
        nftProviderPath: "TopShotProviderForNFTStorefront",
        collectionPath: "/storage/MomentCollection",
        collectionPublicPath: "/public/MomentCollection",
        nftReceiver: "&{TopShot.MomentCollectionPublic}",
        linkArg: "{TopShot.MomentCollectionPublic}",
    },
    Evolution: {
        nftProviderPath: "EvolutionProviderForNFTStorefront",
        collectionPath: "/storage/f4264ac8f3256818_Evolution_Collection",
        collectionPublicPath: "/public/f4264ac8f3256818_Evolution_Collection",
        nftReceiver: "&{Evolution.EvolutionCollectionPublic}",
        linkArg: "{Evolution.EvolutionCollectionPublic}",
    },
    MotoGPCard: {
        nftProviderPath: "MotoGPCardProviderForNFTStorefront",
        collectionPath: "/storage/motogpCardCollection",
        collectionPublicPath: "/public/motogpCardCollection",
        nftReceiver: "&MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}",
        linkArg: "MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}",
    },
    RaribleNFT: {
        nftProviderPath: "RaribleNFTProviderForNFTStorefront",
        collectionPath: "RaribleNFT.collectionStoragePath",
        collectionPublicPath: "RaribleNFT.collectionPublicPath",
        nftReceiver: "&{NonFungibleToken.Receiver}",
        linkArg: "{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}",
    },
    MugenNFT: {
        nftProviderPath: "MugenNFTProviderForNFTStorefront",
        collectionPath: "MugenNFT.CollectionStoragePath",
        collectionPublicPath: "MugenNFT.CollectionPublicPath",
        nftReceiver: "&{NonFungibleToken.CollectionPublic}",
        linkArg: "{NonFungibleToken.CollectionPublic}",
    },
    CNN_NFT: {
        nftProviderPath: "CNN_NFTProviderForNFTStorefront",
        collectionPath: "CNN_NFT.CollectionStoragePath",
        collectionPublicPath: "CNN_NFT.CollectionPublicPath",
        nftReceiver: "&{NonFungibleToken.CollectionPublic}",
        linkArg: "{NonFungibleToken.CollectionPublic}",
    },
};
function getFtCodeConfig(contract) {
    var ftPrivateType = "&{FungibleToken.Provider,FungibleToken.Balance,FungibleToken.Receiver}";
    var knownConf = {
        "@ftContract": contract,
        "@ftPrivateType": ftPrivateType,
        "@ftPrivatePath": "/private/".concat(contract, "_vaultRef"),
    };
    switch (contract) {
        case "FUSD":
            return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, knownConf), { "@ftPublicPath": "/public/fusdReceiver", "@ftStoragePath": "/storage/fusdVault" });
        case "FlowToken":
            return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, knownConf), { "@ftPublicPath": "/public/flowTokenReceiver", "@ftStoragePath": "/storage/flowTokenVault" });
        default:
            throw new Error("Unsupported fungible contract: ".concat(contract));
    }
}
exports.getFtCodeConfig = getFtCodeConfig;
var nftCodeConfig = {
    RaribleNFT: {
        "@nftPublicPath": "RaribleNFT.collectionPublicPath",
        "@nftPublicType": "&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}",
        "@nftStoragePath": "RaribleNFT.collectionStoragePath",
    },
    Evolution: {
        "@nftPublicPath": "/public/f4264ac8f3256818_Evolution_Collection",
        "@nftPublicType": "&{Evolution.EvolutionCollectionPublic}",
        "@nftStoragePath": "/storage/f4264ac8f3256818_Evolution_Collection",
    },
    MotoGPCard: {
        "@nftPublicPath": "/public/motogpCardCollection",
        "@nftPublicType": "&MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}",
        "@nftStoragePath": "/storage/motogpCardCollection",
    },
    TopShot: {
        "@nftPublicPath": "/public/MomentCollection",
        "@nftPublicType": "&{TopShot.MomentCollectionPublic}",
        "@nftStoragePath": "/storage/MomentCollection",
    },
    MugenNFT: {
        "@nftPublicPath": "MugenNFT.CollectionPublicPath",
        "@nftPublicType": "&{NonFungibleToken.CollectionPublic}",
        "@nftStoragePath": "MugenNFT.CollectionStoragePath",
    },
    CNN_NFT: {
        "@nftPublicPath": "CNN_NFT.CollectionPublicPath",
        "@nftPublicType": "&{NonFungibleToken.CollectionPublic}",
        "@nftStoragePath": "CNN_NFT.CollectionStoragePath",
    },
};
function getNftCodeConfig(contract) {
    switch (contract) {
        case "RaribleNFT":
        case "TopShot":
        case "MotoGPCard":
        case "Evolution":
        case "MugenNFT":
        case "CNN_NFT":
            return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, nftCodeConfig[contract]), { "@nftContract": contract, "@nftPrivatePath": "/private/".concat(contract, "_collectionRef"), "@nftPrivateType": "&{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver}", "@nftStorageType": "".concat(contract, ".Collection") });
        default:
            throw new Error("Unsupported contract: ".concat(contract));
    }
}
exports.getNftCodeConfig = getNftCodeConfig;
