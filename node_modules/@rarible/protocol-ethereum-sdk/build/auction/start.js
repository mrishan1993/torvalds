"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartAuction = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var action_1 = require("@rarible/action");
var id_1 = require("../common/id");
var wait_tx_1 = require("../common/wait-tx");
var get_price_1 = require("../common/get-price");
var check_asset_type_1 = require("../order/check-asset-type");
var auction_1 = require("./contracts/auction");
var common_1 = require("./common");
var StartAuction = /** @class */ (function () {
    function StartAuction(ethereum, config, approve, apis) {
        var _this = this;
        this.ethereum = ethereum;
        this.config = config;
        this.approve = approve;
        this.apis = apis;
        this.start = action_1.Action.create({
            id: "approve",
            run: function (request) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                var makeAssetType, _a, _b, _c;
                return (0, tslib_1.__generator)(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (!this.ethereum) {
                                throw new Error("Wallet is undefined");
                            }
                            return [4 /*yield*/, this.checkAssetType(request.makeAssetType)];
                        case 1:
                            makeAssetType = _d.sent();
                            _a = wait_tx_1.waitTx;
                            _b = this.approve;
                            _c = types_1.toAddress;
                            return [4 /*yield*/, this.ethereum.getFrom()];
                        case 2: return [4 /*yield*/, _a.apply(void 0, [_b.apply(this, [_c.apply(void 0, [_d.sent()]),
                                    {
                                        assetType: makeAssetType,
                                        value: request.amount,
                                    },
                                    true])])];
                        case 3:
                            _d.sent();
                            return [2 /*return*/, { request: request, makeAssetType: makeAssetType }];
                    }
                });
            }); },
        })
            .thenStep({
            id: "sign",
            run: function (_a) {
                var request = _a.request, makeAssetType = _a.makeAssetType;
                return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                    var sellAsset, buyAssetType, data, _b, _c, _d, _e, _f, _g;
                    var _h;
                    return (0, tslib_1.__generator)(this, function (_j) {
                        switch (_j.label) {
                            case 0:
                                if (!this.ethereum) {
                                    throw new Error("Wallet is undefined");
                                }
                                sellAsset = {
                                    assetType: {
                                        assetClass: (0, id_1.id)(makeAssetType.assetClass),
                                        data: getAssetEncodedData(this.ethereum, makeAssetType),
                                    },
                                    value: request.amount,
                                };
                                buyAssetType = {
                                    assetClass: (0, id_1.id)(request.takeAssetType.assetClass),
                                    data: getAssetEncodedData(this.ethereum, request.takeAssetType),
                                };
                                _c = (_b = this.ethereum).encodeParameter;
                                _d = [AUCTION_DATA_V1];
                                _h = {
                                    payouts: request.payouts,
                                    originFees: request.originFees,
                                    duration: request.duration,
                                    startTime: request.startTime || 0
                                };
                                return [4 /*yield*/, (0, get_price_1.getPrice)(this.ethereum, request.takeAssetType, request.buyOutPriceDecimal)];
                            case 1:
                                data = _c.apply(_b, _d.concat([(_h.buyOutPrice = (_j.sent()).toString(),
                                        _h)]));
                                _f = (_e = (0, auction_1.createEthereumAuctionContract)(this.ethereum, this.config.auction))
                                    .functionCall;
                                _g = ["startAuction",
                                    sellAsset,
                                    buyAssetType];
                                return [4 /*yield*/, (0, get_price_1.getPrice)(this.ethereum, request.takeAssetType, request.minimalStepDecimal)];
                            case 2:
                                _g = _g.concat([(_j.sent()).toString()]);
                                return [4 /*yield*/, (0, get_price_1.getPrice)(this.ethereum, request.takeAssetType, request.minimalPriceDecimal)];
                            case 3: return [2 /*return*/, _f.apply(_e, _g.concat([(_j.sent()).toString(),
                                    common_1.AUCTION_DATA_TYPE,
                                    data]))
                                    .send({ gas: 10000000 })];
                        }
                    });
                });
            },
        });
        this.checkAssetType = check_asset_type_1.checkAssetType.bind(null, apis.nftCollection);
    }
    return StartAuction;
}());
exports.StartAuction = StartAuction;
var AUCTION_DATA_V1 = {
    components: [
        {
            components: [
                {
                    name: "account",
                    type: "address",
                },
                {
                    name: "value",
                    type: "uint96",
                },
            ],
            name: "payouts",
            type: "tuple[]",
        },
        {
            components: [
                {
                    name: "account",
                    type: "address",
                },
                {
                    name: "value",
                    type: "uint96",
                },
            ],
            name: "originFees",
            type: "tuple[]",
        },
        {
            name: "duration",
            type: "uint96",
        },
        {
            name: "startTime",
            type: "uint96",
        },
        {
            name: "buyOutPrice",
            type: "uint96",
        },
    ],
    name: "data",
    type: "tuple",
};
function getAssetEncodedData(ethereum, asset) {
    switch (asset.assetClass) {
        case "ETH": {
            return "0x";
        }
        case "ERC20": {
            return ethereum.encodeParameter("address", asset.contract);
        }
        case "ERC721":
        case "ERC1155": {
            return ethereum.encodeParameter({
                components: [
                    {
                        name: "contractAddress",
                        type: "address",
                    },
                    {
                        name: "tokenId",
                        type: "uint256",
                    },
                ],
                name: "data",
                type: "tuple",
            }, {
                contractAddress: asset.contract,
                tokenId: asset.tokenId,
            });
        }
        default:
            throw new Error("Unrecognized asset for auction");
    }
}
