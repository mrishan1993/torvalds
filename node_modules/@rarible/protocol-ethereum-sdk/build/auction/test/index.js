"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.increaseTime = exports.testPutBid = exports.awaitForAuction = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var retry_1 = require("../../common/retry");
var common_1 = require("../common");
var wait_tx_1 = require("../../common/wait-tx");
var auction_1 = require("../contracts/auction");
var get_price_1 = require("../../common/get-price");
function awaitForAuction(auctionApi, auctionHash) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _this = this;
        return (0, tslib_1.__generator)(this, function (_a) {
            return [2 /*return*/, (0, retry_1.retry)(60, 1000, function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                    return (0, tslib_1.__generator)(this, function (_a) {
                        return [2 /*return*/, auctionApi.getAuctionByHash({ hash: auctionHash })];
                    });
                }); })];
        });
    });
}
exports.awaitForAuction = awaitForAuction;
function testPutBid(ethereum, config, approve, assetType, request) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var price, _a, _b, _c, _d, bidData, bid, options;
        return (0, tslib_1.__generator)(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _a = types_1.toBigNumber;
                    return [4 /*yield*/, (0, get_price_1.getPrice)(ethereum, assetType, request.priceDecimal)];
                case 1:
                    price = _a.apply(void 0, [(_e.sent()).toString()]);
                    if (!(assetType.assetClass !== "ETH")) return [3 /*break*/, 4];
                    _b = wait_tx_1.waitTx;
                    _c = approve;
                    _d = types_1.toAddress;
                    return [4 /*yield*/, ethereum.getFrom()];
                case 2: return [4 /*yield*/, _b.apply(void 0, [_c.apply(void 0, [_d.apply(void 0, [_e.sent()]),
                            {
                                assetType: assetType,
                                value: price,
                            },
                            true])])];
                case 3:
                    _e.sent();
                    _e.label = 4;
                case 4:
                    bidData = ethereum.encodeParameter(common_1.AUCTION_BID_DATA_V1, {
                        payouts: request.payouts,
                        originFees: request.originFees,
                    });
                    bid = {
                        amount: price,
                        dataType: common_1.AUCTION_DATA_TYPE,
                        data: bidData,
                    };
                    options = (0, common_1.getAuctionOperationOptions)(assetType, price);
                    return [2 /*return*/, (0, auction_1.createEthereumAuctionContract)(ethereum, config.auction)
                            .functionCall("putBid", request.auctionId, bid)
                            .send(options)];
            }
        });
    });
}
exports.testPutBid = testPutBid;
function increaseTime(web3, duration) {
    var id = Date.now();
    return new Promise(function (resolve, reject) {
        web3.currentProvider.send({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [duration],
            id: id,
        }, function (err1) {
            if (err1)
                return reject(err1);
            web3.currentProvider.send({
                jsonrpc: "2.0",
                method: "evm_mine",
                id: id + 1,
            }, function (err2, res) {
                return err2 ? reject(err2) : resolve(res);
            });
        });
    });
}
exports.increaseTime = increaseTime;
