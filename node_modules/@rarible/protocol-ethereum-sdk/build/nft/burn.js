"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.burn = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var utils_1 = require("@rarible/utils");
var get_ownership_id_1 = require("../common/get-ownership-id");
var create_item_id_1 = require("../common/create-item-id");
var erc721_1 = require("./contracts/erc721");
var domain_1 = require("./contracts/domain");
var erc1155_1 = require("./contracts/erc1155");
function burn(ethereum, send, checkAssetType, apis, checkWalletChainId, asset, amount) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var checked, from, _a, ownership, lazyValueBn, _b, _c, _d, _e, erc721Contract, erc1155Contract, owner;
        var _f, _g;
        return (0, tslib_1.__generator)(this, function (_h) {
            switch (_h.label) {
                case 0: return [4 /*yield*/, checkWalletChainId()];
                case 1:
                    _h.sent();
                    if (!ethereum) {
                        throw new Error("Wallet undefined");
                    }
                    return [4 /*yield*/, checkAssetType(asset)];
                case 2:
                    checked = _h.sent();
                    _a = types_1.toAddress;
                    return [4 /*yield*/, ethereum.getFrom()];
                case 3:
                    from = _a.apply(void 0, [_h.sent()]);
                    return [4 /*yield*/, apis.nftOwnership.getNftOwnershipByIdRaw({
                            ownershipId: (0, get_ownership_id_1.getOwnershipId)(asset.contract, (0, types_1.toBigNumber)("" + asset.tokenId), from),
                        })];
                case 4:
                    ownership = _h.sent();
                    if (!(ownership.status === 200)) return [3 /*break*/, 14];
                    lazyValueBn = (0, utils_1.toBn)(ownership.value.lazyValue);
                    if (!lazyValueBn.gt(0)) return [3 /*break*/, 6];
                    if (!lazyValueBn.isEqualTo(ownership.value.value)) {
                        throw new Error("Unable to burn lazy minted item");
                    }
                    _c = (_b = apis.nftItem).deleteLazyMintNftAsset;
                    _f = {
                        itemId: (0, create_item_id_1.createItemId)(asset.contract, (0, types_1.toBigNumber)("" + asset.tokenId))
                    };
                    _g = {
                        creators: ownership.value.creators.map(function (c) { return (0, types_1.toAddress)(c.account); })
                    };
                    _d = types_1.toBinary;
                    return [4 /*yield*/, ethereum.personalSign("I would like to burn my " + asset.tokenId + " item.")];
                case 5: return [2 /*return*/, _c.apply(_b, [(_f.burnLazyNftForm = (_g.signatures = [
                            _d.apply(void 0, [_h.sent()])
                        ],
                            _g),
                            _f)])];
                case 6:
                    _e = checked.assetClass;
                    switch (_e) {
                        case "ERC721": return [3 /*break*/, 7];
                        case "ERC1155": return [3 /*break*/, 9];
                    }
                    return [3 /*break*/, 13];
                case 7: return [4 /*yield*/, (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V2, checked.contract)];
                case 8:
                    erc721Contract = _h.sent();
                    return [2 /*return*/, send(erc721Contract.functionCall("burn", checked.tokenId))];
                case 9:
                    if (!amount) return [3 /*break*/, 12];
                    return [4 /*yield*/, (0, erc1155_1.getErc1155Contract)(ethereum, domain_1.ERC1155VersionEnum.ERC1155V1, checked.contract)];
                case 10:
                    erc1155Contract = _h.sent();
                    return [4 /*yield*/, ethereum.getFrom()];
                case 11:
                    owner = _h.sent();
                    return [2 /*return*/, send(erc1155Contract.functionCall("burn", owner, checked.tokenId, amount))];
                case 12: throw new Error("amount is " + amount + ". Amount for burn ERC1155 is required");
                case 13: throw new Error("Unexpected asset class");
                case 14: throw new Error("Ownership is not found");
            }
        });
    });
}
exports.burn = burn;
