"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertOpenSeaOrderToDTO = void 0;
var types_1 = require("@rarible/types");
var utils_1 = require("@rarible/utils");
var erc721_1 = require("../contracts/erc721");
var erc1155_1 = require("../contracts/erc1155");
var is_nft_1 = require("../is-nft");
var open_sea_types_1 = require("./open-sea-types");
function convertOpenSeaOrderToDTO(ethereum, order) {
    var paymentToken = getPaymentTokenAddress(order);
    if (!paymentToken) {
        throw new Error("Maker or taker should have an ERC20 asset");
    }
    var nftAddress = getNftAddress(order);
    if (!nftAddress) {
        throw new Error("Maker or taker should have an NFT asset");
    }
    var callData;
    var replacementPattern;
    var basePrice;
    var makeAssetType = order.make.assetType;
    var takeAssetType = order.take.assetType;
    if (makeAssetType.assetClass === "ERC721") {
        var c = (0, erc721_1.createErc721Contract)(ethereum, makeAssetType.contract);
        callData = (0, types_1.toBinary)(c.functionCall("transferFrom", order.maker, types_1.ZERO_ADDRESS, makeAssetType.tokenId).data);
        replacementPattern = ERC721_MAKE_REPLACEMENT;
        basePrice = (0, types_1.toBigNumber)(order.take.value);
    }
    else if (makeAssetType.assetClass === "ERC1155") {
        var c = (0, erc1155_1.createErc1155Contract)(ethereum, makeAssetType.contract);
        callData = (0, types_1.toBinary)(c.functionCall("safeTransferFrom", order.maker, types_1.ZERO_ADDRESS, makeAssetType.tokenId, order.make.value, "0x").data);
        replacementPattern = ERC1155_MAKE_REPLACEMENT;
        basePrice = (0, types_1.toBigNumber)(order.take.value);
    }
    else if (takeAssetType.assetClass === "ERC721") {
        var c = (0, erc721_1.createErc721Contract)(ethereum, takeAssetType.contract);
        callData = (0, types_1.toBinary)(c.functionCall("transferFrom", types_1.ZERO_ADDRESS, order.maker, takeAssetType.tokenId).data);
        replacementPattern = ERC721_TAKE_REPLACEMENT;
        basePrice = (0, types_1.toBigNumber)(order.make.value);
    }
    else if (takeAssetType.assetClass === "ERC1155") {
        var c = (0, erc1155_1.createErc1155Contract)(ethereum, takeAssetType.contract);
        callData = (0, types_1.toBinary)(c.functionCall("safeTransferFrom", types_1.ZERO_ADDRESS, order.maker, takeAssetType.tokenId, order.take.value, "0x").data);
        replacementPattern = ERC1155_TAKE_REPLACEMENT;
        basePrice = (0, types_1.toBigNumber)(order.make.value);
    }
    else {
        throw new Error("should never happen");
    }
    return {
        exchange: (0, types_1.toAddress)(order.data.exchange),
        maker: (0, types_1.toAddress)(order.maker),
        taker: (0, types_1.toAddress)(order.taker || types_1.ZERO_ADDRESS),
        makerRelayerFee: (0, types_1.toBigNumber)(order.data.makerRelayerFee),
        takerRelayerFee: (0, types_1.toBigNumber)(order.data.takerRelayerFee),
        makerProtocolFee: (0, types_1.toBigNumber)(order.data.makerProtocolFee),
        takerProtocolFee: (0, types_1.toBigNumber)(order.data.takerProtocolFee),
        feeRecipient: order.data.feeRecipient,
        feeMethod: open_sea_types_1.OrderOpenSeaV1DataV1FeeMethod[order.data.feeMethod],
        side: open_sea_types_1.OrderOpenSeaV1DataV1Side[order.data.side],
        saleKind: open_sea_types_1.OrderOpenSeaV1DataV1SaleKind[order.data.saleKind],
        target: nftAddress,
        howToCall: open_sea_types_1.OrderOpenSeaV1DataV1HowToCall[order.data.howToCall],
        calldata: callData,
        replacementPattern: replacementPattern,
        staticTarget: order.data.staticTarget,
        staticExtradata: order.data.staticExtraData,
        paymentToken: paymentToken,
        basePrice: basePrice,
        extra: (0, types_1.toBigNumber)(order.data.extra),
        listingTime: (0, types_1.toBigNumber)(String(order.start || 0)),
        expirationTime: (0, types_1.toBigNumber)(String(order.end || 0)),
        salt: (0, types_1.toBigNumber)((0, utils_1.toBn)(order.salt).toString(10)),
    };
}
exports.convertOpenSeaOrderToDTO = convertOpenSeaOrderToDTO;
var ERC721_MAKE_REPLACEMENT = (0, types_1.toBinary)("0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000");
var ERC721_TAKE_REPLACEMENT = (0, types_1.toBinary)("0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
var ERC1155_MAKE_REPLACEMENT = (0, types_1.toBinary)("0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
var ERC1155_TAKE_REPLACEMENT = (0, types_1.toBinary)("0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
function getPaymentTokenAddress(order) {
    var makePaymentToken = extractPaymentTokenAddress(order.make.assetType);
    if (makePaymentToken !== undefined) {
        return makePaymentToken;
    }
    var takePaymentToken = extractPaymentTokenAddress(order.take.assetType);
    if (takePaymentToken !== undefined) {
        return takePaymentToken;
    }
    return undefined;
}
function extractPaymentTokenAddress(assetType) {
    switch (assetType.assetClass) {
        case "ETH": return types_1.ZERO_ADDRESS;
        case "ERC20": return assetType.contract;
        default: return undefined;
    }
}
function getNftAddress(order) {
    if ((0, is_nft_1.isNft)(order.make.assetType)) {
        return order.make.assetType.contract;
    }
    if ((0, is_nft_1.isNft)(order.take.assetType)) {
        return order.take.assetType.contract;
    }
    return undefined;
}
