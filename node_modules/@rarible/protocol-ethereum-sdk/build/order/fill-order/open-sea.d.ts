import type { Address, Asset } from "@rarible/ethereum-api-client";
import type { Ethereum, EthereumTransaction } from "@rarible/ethereum-provider";
import type { Maybe } from "@rarible/types/build/maybe";
import type { SendFunction } from "../../common/send-transaction";
import type { EthereumConfig } from "../../config/type";
import type { SimpleOpenSeaV1Order } from "../types";
import type { OpenSeaOrderDTO } from "./open-sea-types";
import type { OpenSeaV1OrderFillRequest, OrderHandler } from "./types";
import type { OrderFillSendData } from "./types";
export declare class OpenSeaOrderHandler implements OrderHandler<OpenSeaV1OrderFillRequest> {
    private readonly ethereum;
    private readonly send;
    private readonly config;
    constructor(ethereum: Maybe<Ethereum>, send: SendFunction, config: EthereumConfig);
    invert({ order }: OpenSeaV1OrderFillRequest, maker: Address): SimpleOpenSeaV1Order;
    getBaseOrderFee(order: SimpleOpenSeaV1Order): number;
    getOrderFee(order: SimpleOpenSeaV1Order): number;
    approve(order: SimpleOpenSeaV1Order, infinite: boolean): Promise<void>;
    getTransactionData(initial: SimpleOpenSeaV1Order, inverted: SimpleOpenSeaV1Order): Promise<OrderFillSendData>;
    sendTransaction(initial: SimpleOpenSeaV1Order, inverted: SimpleOpenSeaV1Order): Promise<EthereumTransaction>;
    approveSingle(maker: Address, asset: Asset, infinite?: undefined | boolean): Promise<EthereumTransaction | undefined>;
    private getRegisteredProxy;
}
export declare function getAtomicMatchArgAddresses(dto: OpenSeaOrderDTO): Address[];
export declare function getAtomicMatchArgUints(dto: OpenSeaOrderDTO): import("@rarible/ethereum-api-client").BigNumber[];
export declare function getAtomicMatchArgCommonData(dto: OpenSeaOrderDTO): (import("./open-sea-types").OrderOpenSeaV1DataV1FeeMethod | import("./open-sea-types").OrderOpenSeaV1DataV1Side | import("./open-sea-types").OrderOpenSeaV1DataV1SaleKind | import("./open-sea-types").OrderOpenSeaV1DataV1HowToCall)[];
