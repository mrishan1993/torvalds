"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAtomicMatchArgCommonData = exports.getAtomicMatchArgUints = exports.getAtomicMatchArgAddresses = exports.OpenSeaOrderHandler = void 0;
var tslib_1 = require("tslib");
var ethereum_api_client_1 = require("@rarible/ethereum-api-client");
var types_1 = require("@rarible/types");
var exponential_backoff_1 = require("exponential-backoff");
var utils_1 = require("@rarible/utils");
var proxy_registry_opensea_1 = require("../contracts/proxy-registry-opensea");
var approve_erc20_1 = require("../approve-erc20");
var approve_erc721_1 = require("../approve-erc721");
var approve_erc1155_1 = require("../approve-erc1155");
var get_asset_with_fee_1 = require("../get-asset-with-fee");
var exchange_opensea_v1_1 = require("../contracts/exchange-opensea-v1");
var to_vrs_1 = require("../../common/to-vrs");
var wait_tx_1 = require("../../common/wait-tx");
var open_sea_converter_1 = require("./open-sea-converter");
var OpenSeaOrderHandler = /** @class */ (function () {
    function OpenSeaOrderHandler(ethereum, send, config) {
        this.ethereum = ethereum;
        this.send = send;
        this.config = config;
    }
    OpenSeaOrderHandler.prototype.invert = function (_a, maker) {
        var order = _a.order;
        if (order.data.side === "BUY" && order.make.assetType.assetClass === "ETH") {
            throw new Error("BUY order with make=ETH can be only");
        }
        if (order.data.feeRecipient === types_1.ZERO_ADDRESS) {
            throw new Error("feeRecipient should be specified");
        }
        var data = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order.data), { feeRecipient: types_1.ZERO_ADDRESS, side: order.data.side === ethereum_api_client_1.OrderOpenSeaV1DataV1Side.BUY
                ? ethereum_api_client_1.OrderOpenSeaV1DataV1Side.SELL
                : ethereum_api_client_1.OrderOpenSeaV1DataV1Side.BUY });
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order), { make: (0, tslib_1.__assign)({}, order.take), take: (0, tslib_1.__assign)({}, order.make), maker: maker, taker: order.maker, signature: undefined, data: data });
    };
    OpenSeaOrderHandler.prototype.getBaseOrderFee = function (order) {
        if (order.data.feeRecipient === types_1.ZERO_ADDRESS) {
            return (0, utils_1.toBn)(order.data.takerProtocolFee).plus(order.data.takerRelayerFee).toNumber();
        }
        else {
            return (0, utils_1.toBn)(order.data.makerProtocolFee).plus(order.data.makerRelayerFee).toNumber();
        }
    };
    OpenSeaOrderHandler.prototype.getOrderFee = function (order) {
        return this.getBaseOrderFee(order);
    };
    OpenSeaOrderHandler.prototype.approve = function (order, infinite) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var fee, assetWithFee, value, feeOnly;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fee = this.getOrderFee(order);
                        if (!(order.data.side === "BUY")) return [3 /*break*/, 2];
                        assetWithFee = (0, get_asset_with_fee_1.getAssetWithFee)(order.make, fee);
                        return [4 /*yield*/, (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, assetWithFee, infinite))];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 2: return [4 /*yield*/, (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, order.make, infinite))];
                    case 3:
                        _a.sent();
                        value = (0, utils_1.toBn)(order.take.value)
                            .multipliedBy(fee)
                            .dividedBy(10000)
                            .integerValue(utils_1.BigNumber.ROUND_FLOOR)
                            .toFixed();
                        feeOnly = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order.take), { value: (0, types_1.toBigNumber)(value) });
                        return [4 /*yield*/, (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, feeOnly, infinite))];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.getTransactionData = function (initial, inverted) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, buy, sell, sellOrderToSignDTO, buyOrderToSignDTO, exchangeContract, buyVRS, sellVRS, functionCall;
            var _b;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        _a = getBuySellOrders(initial, inverted), buy = _a.buy, sell = _a.sell;
                        sellOrderToSignDTO = (0, open_sea_converter_1.convertOpenSeaOrderToDTO)(this.ethereum, sell);
                        buyOrderToSignDTO = (0, open_sea_converter_1.convertOpenSeaOrderToDTO)(this.ethereum, buy);
                        exchangeContract = (0, exchange_opensea_v1_1.createOpenseaContract)(this.ethereum, this.config.exchange.openseaV1);
                        buyVRS = (0, to_vrs_1.toVrs)(buy.signature || "");
                        sellVRS = (0, to_vrs_1.toVrs)(sell.signature || "");
                        functionCall = exchangeContract.functionCall("atomicMatch_", (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgAddresses(buyOrderToSignDTO), true), getAtomicMatchArgAddresses(sellOrderToSignDTO), true), (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgUints(buyOrderToSignDTO), true), getAtomicMatchArgUints(sellOrderToSignDTO), true), (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgCommonData(buyOrderToSignDTO), true), getAtomicMatchArgCommonData(sellOrderToSignDTO), true), buyOrderToSignDTO.calldata, sellOrderToSignDTO.calldata, buyOrderToSignDTO.replacementPattern, sellOrderToSignDTO.replacementPattern, buyOrderToSignDTO.staticExtradata, sellOrderToSignDTO.staticExtradata, [buyVRS.v, sellVRS.v], [buyVRS.r, buyVRS.s, sellVRS.r, sellVRS.s, this.config.openSea.metadata]);
                        _b = {
                            functionCall: functionCall
                        };
                        return [4 /*yield*/, getMatchOpenseaOptions(buy)];
                    case 1: return [2 /*return*/, (_b.options = _c.sent(),
                            _b)];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.sendTransaction = function (initial, inverted) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, functionCall, options;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getTransactionData(initial, inverted)];
                    case 1:
                        _a = _b.sent(), functionCall = _a.functionCall, options = _a.options;
                        return [2 /*return*/, this.send(functionCall, options)];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.approveSingle = function (maker, asset, infinite) {
        if (infinite === void 0) { infinite = true; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, contract, operator, contract, proxyAddress, contract, proxyAddress;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        _a = asset.assetType.assetClass;
                        switch (_a) {
                            case "ERC20": return [3 /*break*/, 1];
                            case "ERC721": return [3 /*break*/, 2];
                            case "ERC1155": return [3 /*break*/, 4];
                        }
                        return [3 /*break*/, 6];
                    case 1:
                        {
                            contract = asset.assetType.contract;
                            operator = this.config.transferProxies.openseaV1;
                            return [2 /*return*/, (0, approve_erc20_1.approveErc20)(this.ethereum, this.send, contract, maker, operator, asset.value, infinite)];
                        }
                        _b.label = 2;
                    case 2:
                        contract = asset.assetType.contract;
                        return [4 /*yield*/, this.getRegisteredProxy(maker)];
                    case 3:
                        proxyAddress = _b.sent();
                        return [2 /*return*/, (0, approve_erc721_1.approveErc721)(this.ethereum, this.send, contract, maker, proxyAddress)];
                    case 4:
                        contract = asset.assetType.contract;
                        return [4 /*yield*/, this.getRegisteredProxy(maker)];
                    case 5:
                        proxyAddress = _b.sent();
                        return [2 /*return*/, (0, approve_erc1155_1.approveErc1155)(this.ethereum, this.send, contract, maker, proxyAddress)];
                    case 6: return [2 /*return*/, undefined];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.getRegisteredProxy = function (maker) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var proxyRegistry, proxyRegistryContract, proxyAddress, registerTx;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        proxyRegistry = this.config.openSea.proxyRegistry;
                        proxyRegistryContract = (0, proxy_registry_opensea_1.createOpenseaProxyRegistryEthContract)(this.ethereum, proxyRegistry);
                        return [4 /*yield*/, getSenderProxy(proxyRegistryContract, maker)];
                    case 1:
                        proxyAddress = _a.sent();
                        if (!(proxyAddress === types_1.ZERO_ADDRESS)) return [3 /*break*/, 4];
                        return [4 /*yield*/, proxyRegistryContract.functionCall("registerProxy").send()];
                    case 2:
                        registerTx = _a.sent();
                        return [4 /*yield*/, registerTx.wait()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, (0, exponential_backoff_1.backOff)(function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                                var value;
                                return (0, tslib_1.__generator)(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, getSenderProxy(proxyRegistryContract, maker)];
                                        case 1:
                                            value = _a.sent();
                                            if (value === types_1.ZERO_ADDRESS) {
                                                throw new Error("Expected non-zero proxy address");
                                            }
                                            return [2 /*return*/, value];
                                    }
                                });
                            }); }, {
                                maxDelay: 500,
                                numOfAttempts: 10,
                                delayFirstAttempt: true,
                                startingDelay: 100,
                            })];
                    case 4: return [2 /*return*/, proxyAddress];
                }
            });
        });
    };
    return OpenSeaOrderHandler;
}());
exports.OpenSeaOrderHandler = OpenSeaOrderHandler;
function getMatchOpenseaOptions(buy) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var fee, assetWithFee;
        return (0, tslib_1.__generator)(this, function (_a) {
            if (buy.make.assetType.assetClass === "ETH") {
                fee = (0, utils_1.toBn)(buy.data.takerProtocolFee).plus(buy.data.takerRelayerFee).toNumber();
                assetWithFee = (0, get_asset_with_fee_1.getAssetWithFee)(buy.make, fee);
                return [2 /*return*/, { value: assetWithFee.value }];
            }
            else {
                return [2 /*return*/, {}];
            }
            return [2 /*return*/];
        });
    });
}
function getSenderProxy(registryContract, sender) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _a;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = types_1.toAddress;
                    return [4 /*yield*/, registryContract.functionCall("proxies", sender).call()];
                case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
            }
        });
    });
}
function getBuySellOrders(left, right) {
    if (left.data.side === "SELL") {
        return {
            buy: right,
            sell: left,
        };
    }
    else {
        return {
            buy: left,
            sell: right,
        };
    }
}
function getAtomicMatchArgAddresses(dto) {
    return [dto.exchange, dto.maker, dto.taker, dto.feeRecipient, dto.target, dto.staticTarget, dto.paymentToken];
}
exports.getAtomicMatchArgAddresses = getAtomicMatchArgAddresses;
function getAtomicMatchArgUints(dto) {
    return [
        dto.makerRelayerFee,
        dto.takerRelayerFee,
        dto.makerProtocolFee,
        dto.takerProtocolFee,
        dto.basePrice,
        dto.extra,
        dto.listingTime,
        dto.expirationTime,
        dto.salt,
    ];
}
exports.getAtomicMatchArgUints = getAtomicMatchArgUints;
function getAtomicMatchArgCommonData(dto) {
    return [dto.feeMethod, dto.side, dto.saleKind, dto.howToCall];
}
exports.getAtomicMatchArgCommonData = getAtomicMatchArgCommonData;
