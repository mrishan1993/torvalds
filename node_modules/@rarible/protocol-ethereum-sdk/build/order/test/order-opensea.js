"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashOpenSeaV1Order = exports.hashToSign = exports.hashOrder = exports.getOrderSignature = exports.getOrderTemplate = exports.OPENSEA_ORDER_TEMPLATE = exports.getAssetTypeBlank = void 0;
var tslib_1 = require("tslib");
var ethereum_api_client_1 = require("@rarible/ethereum-api-client");
var types_1 = require("@rarible/types");
var ethers_1 = require("ethers");
var open_sea_converter_1 = require("../fill-order/open-sea-converter");
function getRandomTokenId() {
    return Math.floor(Math.random() * 300000000).toString();
}
function getAssetTypeBlank(assetClass) {
    switch (assetClass) {
        case "ETH": {
            return {
                assetType: {
                    assetClass: "ETH",
                },
                value: (0, types_1.toBigNumber)("100"),
            };
        }
        case "ERC20": {
            return {
                assetType: {
                    assetClass: "ERC20",
                    contract: (0, types_1.toAddress)(types_1.ZERO_ADDRESS),
                },
                value: (0, types_1.toBigNumber)("100"),
            };
        }
        case "ERC721": {
            return {
                assetType: {
                    assetClass: "ERC721",
                    contract: (0, types_1.toAddress)(types_1.ZERO_ADDRESS),
                    tokenId: (0, types_1.toBigNumber)(getRandomTokenId()),
                },
                value: (0, types_1.toBigNumber)("1"),
            };
        }
        case "ERC1155": {
            return {
                assetType: {
                    assetClass: "ERC1155",
                    contract: (0, types_1.toAddress)(types_1.ZERO_ADDRESS),
                    tokenId: (0, types_1.toBigNumber)(getRandomTokenId()),
                },
                value: (0, types_1.toBigNumber)("100"),
            };
        }
        default:
            throw new Error("Unrecognized asset type");
    }
}
exports.getAssetTypeBlank = getAssetTypeBlank;
exports.OPENSEA_ORDER_TEMPLATE = {
    maker: (0, types_1.toAddress)(types_1.ZERO_ADDRESS),
    salt: (0, types_1.toWord)("0x000000000000000000000000000000000000000000000000000000000000000a"),
    type: "OPEN_SEA_V1",
    start: 0,
    end: 0,
    data: {
        dataType: "OPEN_SEA_V1_DATA_V1",
        exchange: (0, types_1.toAddress)(types_1.ZERO_ADDRESS),
        makerRelayerFee: (0, types_1.toBigNumber)("0"),
        takerRelayerFee: (0, types_1.toBigNumber)("0"),
        makerProtocolFee: (0, types_1.toBigNumber)("0"),
        takerProtocolFee: (0, types_1.toBigNumber)("0"),
        feeRecipient: (0, types_1.toAddress)(types_1.ZERO_ADDRESS),
        feeMethod: ethereum_api_client_1.OrderOpenSeaV1DataV1FeeMethod.SPLIT_FEE,
        side: ethereum_api_client_1.OrderOpenSeaV1DataV1Side.SELL,
        saleKind: ethereum_api_client_1.OrderOpenSeaV1DataV1SaleKind.FIXED_PRICE,
        howToCall: ethereum_api_client_1.OrderOpenSeaV1DataV1HowToCall.CALL,
        callData: (0, types_1.toBinary)("0x"),
        replacementPattern: (0, types_1.toBinary)("0x"),
        staticTarget: types_1.ZERO_ADDRESS,
        staticExtraData: (0, types_1.toBinary)("0x"),
        extra: (0, types_1.toBigNumber)("0"),
    },
};
function getOrderTemplate(makeAsset, takeAsset, side) {
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, exports.OPENSEA_ORDER_TEMPLATE), { make: getAssetTypeBlank(makeAsset), take: getAssetTypeBlank(takeAsset), data: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, exports.OPENSEA_ORDER_TEMPLATE.data), { callData: (0, types_1.toBinary)("0xf242432a00000000000000000000000000d5cbc289e4b66a6252949d6eb6ebbb12df24ab00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000"), replacementPattern: (0, types_1.toBinary)("0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"), side: side }) });
}
exports.getOrderTemplate = getOrderTemplate;
//TODO replace web3.eth.sign
function getOrderSignature(ethereum, order) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var web3, from;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    web3 = ethereum["config"].web3;
                    return [4 /*yield*/, ethereum.getFrom()
                        // return ethereum.ethSign(hashOpenSeaV1Order(ethereum, order))
                    ];
                case 1:
                    from = _a.sent();
                    // return ethereum.ethSign(hashOpenSeaV1Order(ethereum, order))
                    return [2 /*return*/, web3.eth.sign(hashOpenSeaV1Order(ethereum, order), from)];
            }
        });
    });
}
exports.getOrderSignature = getOrderSignature;
var hashOrderType = [
    "address",
    "address",
    "address",
    "uint",
    "uint",
    "uint",
    "uint",
    "address",
    "uint8",
    "uint8",
    "uint8",
    "address",
    "uint8",
    "bytes",
    "bytes",
    "address",
    "bytes",
    "address",
    "uint",
    "uint",
    "uint",
    "uint",
    "uint",
];
function hashOrder(order) {
    return ethers_1.ethers.utils.solidityKeccak256(hashOrderType, [
        order.exchange,
        order.maker,
        order.taker,
        order.makerRelayerFee,
        order.takerRelayerFee,
        order.makerProtocolFee,
        order.takerProtocolFee,
        order.feeRecipient,
        order.feeMethod,
        order.side,
        order.saleKind,
        order.target,
        order.howToCall,
        order.calldata,
        order.replacementPattern,
        order.staticTarget,
        order.staticExtradata,
        order.paymentToken,
        order.basePrice,
        order.extra,
        order.listingTime,
        order.expirationTime,
        order.salt,
    ]);
}
exports.hashOrder = hashOrder;
function hashToSign(hash) {
    return ethers_1.ethers.utils.solidityKeccak256(["string", "bytes32"], ["\x19Ethereum Signed Message:\n32", hash]);
}
exports.hashToSign = hashToSign;
function hashOpenSeaV1Order(ethereum, order) {
    return hashOrder((0, open_sea_converter_1.convertOpenSeaOrderToDTO)(ethereum, order));
}
exports.hashOpenSeaV1Order = hashOpenSeaV1Order;
