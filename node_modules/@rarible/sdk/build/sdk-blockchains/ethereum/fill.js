"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumFill = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var EthereumApiClient = (0, tslib_1.__importStar)(require("@rarible/ethereum-api-client"));
var bn_1 = require("@rarible/utils/build/bn");
var sdk_transaction_1 = require("@rarible/sdk-transaction");
var is_nft_1 = require("@rarible/protocol-ethereum-sdk/build/order/is-nft");
var get_ownership_id_1 = require("@rarible/protocol-ethereum-sdk/build/common/get-ownership-id");
var domain_1 = require("../../types/order/fill/domain");
var common_1 = require("./common");
var EthereumFill = /** @class */ (function () {
    function EthereumFill(sdk, wallet, network) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.network = network;
        this.fill = this.fill.bind(this);
        this.buy = this.buy.bind(this);
        this.acceptBid = this.acceptBid.bind(this);
    }
    EthereumFill.prototype.convertToSimpleOrder = function (order) {
        var common = {
            maker: (0, common_1.convertToEthereumAddress)(order.maker),
            taker: order.taker && (0, common_1.convertToEthereumAddress)(order.taker),
            make: {
                assetType: (0, common_1.convertToEthereumAssetType)(order.make.type),
                value: order.make.value,
            },
            take: {
                assetType: (0, common_1.convertToEthereumAssetType)(order.take.type),
                value: order.take.value,
            },
            salt: (0, types_1.toWord)(order.salt),
            start: order.startedAt !== undefined ? parseInt(order.startedAt) : undefined,
            end: order.endedAt !== undefined ? parseInt(order.endedAt) : undefined,
            signature: order.signature !== undefined ? (0, types_1.toBinary)(order.signature) : undefined,
            makeStock: order.makeStock,
        };
        switch (order.data["@type"]) {
            case "ETH_RARIBLE_V1": {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, common), { type: "RARIBLE_V1", data: {
                        dataType: "LEGACY",
                        fee: parseInt(order.data.fee),
                    } });
            }
            case "ETH_RARIBLE_V2": {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, common), { type: "RARIBLE_V2", data: {
                        dataType: "RARIBLE_V2_DATA_V1",
                        payouts: order.data.payouts.map(function (p) { return ({
                            account: (0, common_1.convertToEthereumAddress)(p.account),
                            value: p.value,
                        }); }),
                        originFees: order.data.originFees.map(function (fee) { return ({
                            account: (0, common_1.convertToEthereumAddress)(fee.account),
                            value: fee.value,
                        }); }),
                    } });
            }
            case "ETH_CRYPTO_PUNKS": {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, common), { type: "CRYPTO_PUNK", data: {
                        dataType: "CRYPTO_PUNKS_DATA",
                    } });
            }
            case "ETH_OPEN_SEA_V1": {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, common), { type: "OPEN_SEA_V1", data: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order.data), { dataType: "OPEN_SEA_V1_DATA_V1", exchange: (0, common_1.convertToEthereumAddress)(order.data.exchange), feeRecipient: (0, common_1.convertToEthereumAddress)(order.data.feeRecipient), feeMethod: EthereumApiClient.OrderOpenSeaV1DataV1FeeMethod[order.data.feeMethod], side: EthereumApiClient.OrderOpenSeaV1DataV1Side[order.data.side], saleKind: EthereumApiClient.OrderOpenSeaV1DataV1SaleKind[order.data.saleKind], howToCall: EthereumApiClient.OrderOpenSeaV1DataV1HowToCall[order.data.howToCall], callData: (0, types_1.toBinary)(order.data.callData), replacementPattern: (0, types_1.toBinary)(order.data.callData), staticExtraData: (0, types_1.toBinary)(order.data.staticExtraData), staticTarget: (0, common_1.convertToEthereumAddress)(order.data.staticTarget) }) });
            }
            default: {
                throw new Error("Unsupported order data type " + order.data["@type"]);
            }
        }
    };
    EthereumFill.prototype.getFillAssetType = function (assetType) {
        switch (assetType["@type"]) {
            case "ERC721":
            case "ERC721_Lazy":
            case "ERC1155":
            case "ERC1155_Lazy":
            case "CRYPTO_PUNKS":
                return (0, common_1.convertToEthereumAssetType)(assetType);
            default: throw new Error("Wrong asset type for fill action");
        }
    };
    EthereumFill.prototype.getFillOrderRequest = function (order, fillRequest) {
        var _a, _b, _c, _d, _e, _f;
        var request;
        switch (order.type) {
            case "RARIBLE_V1": {
                request = {
                    order: order,
                    amount: fillRequest.amount,
                    infinite: fillRequest.infiniteApproval,
                    originFee: ((_b = (_a = fillRequest.originFees) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.value) ? fillRequest.originFees[0].value : 0,
                    payout: ((_d = (_c = fillRequest.payouts) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.account)
                        ? (0, common_1.convertToEthereumAddress)(fillRequest.payouts[0].account)
                        : undefined,
                };
                break;
            }
            case "RARIBLE_V2": {
                request = {
                    order: order,
                    amount: fillRequest.amount,
                    infinite: fillRequest.infiniteApproval,
                    payouts: (_e = fillRequest.payouts) === null || _e === void 0 ? void 0 : _e.map(function (payout) { return ({
                        account: (0, common_1.convertToEthereumAddress)(payout.account),
                        value: payout.value,
                    }); }),
                    originFees: (_f = fillRequest.originFees) === null || _f === void 0 ? void 0 : _f.map(function (fee) { return ({
                        account: (0, common_1.convertToEthereumAddress)(fee.account),
                        value: fee.value,
                    }); }),
                };
                break;
            }
            case "OPEN_SEA_V1": {
                request = {
                    order: order,
                    infinite: fillRequest.infiniteApproval,
                };
                break;
            }
            default: {
                throw new Error("Unsupported order type");
            }
        }
        if (fillRequest.assetType) {
            request.assetType = this.getFillAssetType(fillRequest.assetType);
        }
        return request;
    };
    EthereumFill.prototype.getSupportFlags = function (order) {
        switch (order.type) {
            case "RARIBLE_V1": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.AMOUNT_ONLY,
                    payoutsSupport: domain_1.PayoutsSupport.SINGLE,
                    supportsPartialFill: true,
                };
            }
            case "RARIBLE_V2": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                    supportsPartialFill: true,
                };
            }
            case "OPEN_SEA_V1": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.NONE,
                    payoutsSupport: domain_1.PayoutsSupport.NONE,
                    supportsPartialFill: false,
                };
            }
            default: throw new Error("Unsupported order type");
        }
    };
    EthereumFill.prototype.getMaxAmount = function (order) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var address, ownershipId, ownership;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (order.take.assetType.assetClass === "COLLECTION") {
                            return [2 /*return*/, null];
                        }
                        if (!(0, is_nft_1.isNft)(order.take.assetType)) return [3 /*break*/, 3];
                        if (this.wallet === undefined) {
                            throw new Error("Wallet undefined");
                        }
                        return [4 /*yield*/, this.wallet.ethereum.getFrom()];
                    case 1:
                        address = _a.sent();
                        ownershipId = (0, get_ownership_id_1.getOwnershipId)(order.take.assetType.contract, order.take.assetType.tokenId, (0, types_1.toAddress)(address));
                        return [4 /*yield*/, this.sdk.apis.nftOwnership.getNftOwnershipById({ ownershipId: ownershipId })];
                    case 2:
                        ownership = _a.sent();
                        return [2 /*return*/, (0, types_1.toBigNumber)(bn_1.BigNumber.min(ownership.value, order.take.value).toFixed())];
                    case 3: return [2 /*return*/, order.makeStock];
                }
            });
        });
    };
    EthereumFill.prototype.isMultiple = function (order) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var contract, collection;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ((0, is_nft_1.isNft)(order.take.assetType) || order.take.assetType.assetClass === "COLLECTION") {
                            contract = order.take.assetType.contract;
                        }
                        else if ((0, is_nft_1.isNft)(order.make.assetType) || order.make.assetType.assetClass === "COLLECTION") {
                            contract = order.make.assetType.contract;
                        }
                        else {
                            throw new Error("Nft has not been found");
                        }
                        return [4 /*yield*/, this.sdk.apis.nftCollection.getNftCollectionById({
                                collection: contract,
                            })];
                    case 1:
                        collection = _a.sent();
                        return [2 /*return*/, collection.type === "ERC1155"];
                }
            });
        });
    };
    EthereumFill.prototype.getPreparedOrder = function (request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, domain, hash;
            return (0, tslib_1.__generator)(this, function (_b) {
                if ("order" in request) {
                    return [2 /*return*/, this.convertToSimpleOrder(request.order)];
                }
                else if ("orderId" in request) {
                    _a = request.orderId.split(":"), domain = _a[0], hash = _a[1];
                    if (!(0, common_1.isEVMBlockchain)(domain)) {
                        throw new Error("Not an ethereum order");
                    }
                    return [2 /*return*/, this.sdk.apis.order.getOrderByHash({ hash: hash })];
                }
                throw new Error("Incorrect request");
            });
        });
    };
    EthereumFill.prototype.hasCollectionAssetType = function (order) {
        return order.take.assetType.assetClass === "COLLECTION" || order.make.assetType.assetClass === "COLLECTION";
    };
    EthereumFill.prototype.commonFill = function (action, request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var order, submit, _a;
            var _b;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getPreparedOrder(request)];
                    case 1:
                        order = _c.sent();
                        submit = action
                            .before(function (fillRequest) {
                            if (_this.hasCollectionAssetType(order) && !fillRequest.assetType) {
                                throw new Error("For collection order you should pass asset type");
                            }
                            return _this.getFillOrderRequest(order, fillRequest);
                        })
                            .after((function (tx) { return new sdk_transaction_1.BlockchainEthereumTransaction(tx, _this.network); }));
                        _a = [(0, tslib_1.__assign)({}, this.getSupportFlags(order))];
                        _b = {};
                        return [4 /*yield*/, this.isMultiple(order)];
                    case 2:
                        _b.multiple = _c.sent();
                        return [4 /*yield*/, this.getMaxAmount(order)];
                    case 3:
                        _b.maxAmount = _c.sent();
                        return [4 /*yield*/, this.sdk.order.getBaseOrderFillFee(order)];
                    case 4: return [2 /*return*/, tslib_1.__assign.apply(void 0, _a.concat([(_b.baseFee = _c.sent(), _b.submit = submit, _b)]))];
                }
            });
        });
    };
    /**
     * @deprecated
     * @param request
     */
    EthereumFill.prototype.fill = function (request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, this.commonFill(this.sdk.order.fill, request)];
            });
        });
    };
    EthereumFill.prototype.buy = function (request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, this.commonFill(this.sdk.order.buy, request)];
            });
        });
    };
    EthereumFill.prototype.acceptBid = function (request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, this.commonFill(this.sdk.order.acceptBid, request)];
            });
        });
    };
    return EthereumFill;
}());
exports.EthereumFill = EthereumFill;
