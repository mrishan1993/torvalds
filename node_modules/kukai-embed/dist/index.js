"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _iframe, _messages, _icon, _user;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KukaiEmbed = exports.Networks = void 0;
const types_1 = require("./types");
Object.defineProperty(exports, "Networks", { enumerable: true, get: function () { return types_1.Networks; } });
const util_1 = require("./util");
const iframe_1 = require("./iframe");
const icon_1 = require("./icon");
const messages_1 = require("./messages");
__exportStar(require("./types"), exports);
const storeKey = 'kukai-embed-instance-id';
class KukaiEmbed {
    /**
     * Constructs a {@link KukaiEmbed} instance, using the given network OR with override src
     *
     * @param network - The network which the Kukai instance will use, OR the source of the Kukai instance
     */
    constructor(cfg = {}) {
        _iframe.set(this, void 0);
        _messages.set(this, void 0);
        _icon.set(this, null);
        _user.set(this, null);
        const fullCfg = {
            net: types_1.Networks.mainnet,
            icon: false,
            enableLogging: (cfg.net !== undefined && cfg.net !== types_1.Networks.mainnet),
            ...cfg
        };
        const iframeSrc = util_1.networkToSrc(fullCfg.net);
        const k = new iframe_1.IFrameKukai(iframeSrc);
        __classPrivateFieldSet(this, _iframe, k);
        __classPrivateFieldSet(this, _messages, new messages_1.KukaiMessaging(k, iframeSrc, fullCfg.enableLogging));
        if (fullCfg.icon) {
            __classPrivateFieldSet(this, _icon, new icon_1.IconUI());
        }
    }
    /**
     * Initializes the Kukai Embed in the page
     *
     * @remarks
     * This method injects an IFrame into the document body which contains a Kukai instance. The returned
     * promise resolves when the iframe content has finished loading and a message has been exchanged with
     * the Kukai instance
     */
    async init() {
        var _a;
        if (this.initialized) {
            throw new Error("Kukai-Embed Already Present");
        }
        const id = window.sessionStorage.getItem(storeKey);
        const instanceId = id ? id : undefined;
        let init = async (id) => {
            // begin waiting for init message
            let p = __classPrivateFieldGet(this, _messages).init(window);
            // add iframe to document body, Kukai embedded component should send an init message once init is complete
            __classPrivateFieldGet(this, _iframe).init(instanceId);
            // await the init message
            return await p;
        };
        if (instanceId) {
            const user = window.sessionStorage.getItem(instanceId);
            if (user) {
                await init(instanceId);
                __classPrivateFieldSet(this, _user, JSON.parse(user));
                __classPrivateFieldGet(this, _iframe).toCard();
                __classPrivateFieldGet(this, _iframe).hide();
                (_a = __classPrivateFieldGet(this, _icon)) === null || _a === void 0 ? void 0 : _a.init(() => this.toggle()).then(() => { var _a; return (_a = __classPrivateFieldGet(this, _icon)) === null || _a === void 0 ? void 0 : _a.show(); });
            }
            else {
                await init();
            }
        }
        else {
            await init();
        }
    }
    /**
     * Indicates whether the embed is fully initialized
     *
     * @returns the initialization state of the embed
     */
    get initialized() {
        return __classPrivateFieldGet(this, _iframe).isInit && __classPrivateFieldGet(this, _messages).isInit;
    }
    deinit() {
        var _a;
        __classPrivateFieldGet(this, _messages).deinit();
        __classPrivateFieldGet(this, _iframe).deinit();
        (_a = __classPrivateFieldGet(this, _icon)) === null || _a === void 0 ? void 0 : _a.deinit();
    }
    get user() {
        return __classPrivateFieldGet(this, _user);
    }
    /**
     * Initiates the User Login flow for the embed
     *
     * @remarks
     * This will {@link KukaiEmbed.show | show} the embed containing a DirectAuth component
     *
     * @returns the Login information for the User
     */
    async login(config = {}) {
        var _a;
        if (!this.initialized) {
            throw new Error("Cannot login: Embed Uninitialized");
        }
        if ((_a = this.user) === null || _a === void 0 ? void 0 : _a.pk) {
            throw new Error("Already logged in");
        }
        __classPrivateFieldGet(this, _iframe).toFullScreen();
        __classPrivateFieldGet(this, _iframe).show();
        return await __classPrivateFieldGet(this, _messages).login(config).then(({ pk, pkh, userData, instanceId }) => {
            var _a;
            window.sessionStorage.setItem(storeKey, instanceId);
            window.sessionStorage.setItem(instanceId, JSON.stringify({ pk, pkh, userData }));
            (_a = __classPrivateFieldGet(this, _icon)) === null || _a === void 0 ? void 0 : _a.init(() => this.toggle()).then(() => { var _a; return (_a = __classPrivateFieldGet(this, _icon)) === null || _a === void 0 ? void 0 : _a.show(); });
            __classPrivateFieldSet(this, _user, { pk, pkh, userData });
            const callback = async () => {
                return await __classPrivateFieldGet(this, _messages).dismiss()
                    .finally(() => {
                    __classPrivateFieldGet(this, _iframe).hide();
                    __classPrivateFieldGet(this, _iframe).toCard();
                });
            };
            return !config.customSpinnerDismissal ? __classPrivateFieldGet(this, _user) : { ...__classPrivateFieldGet(this, _user), dismissCallback: callback };
        }).catch((e) => {
            config.customSpinnerDismissal = false;
            throw e;
        }).finally(() => {
            if (!config.customSpinnerDismissal) {
                __classPrivateFieldGet(this, _iframe).hide();
                __classPrivateFieldGet(this, _iframe).toCard();
            }
        });
    }
    /**
     * Logs out of the embedded Kukai instance
     *
     * @returns the Logout result with potential error info
     */
    async logout() {
        if (!this.initialized) {
            throw new Error("Cannot logout: Embed Uninitialized");
        }
        if (__classPrivateFieldGet(this, _iframe).isCard() && !__classPrivateFieldGet(this, _iframe).isHidden())
            await __classPrivateFieldGet(this, _messages).card(false);
        return await __classPrivateFieldGet(this, _messages).logout()
            .then(res => {
            var _a, _b;
            try {
                const id = window.sessionStorage.getItem(storeKey);
                const instanceId = id ? id : undefined;
                if (instanceId)
                    window.sessionStorage.removeItem(instanceId);
            }
            catch (_c) { }
            window.sessionStorage.removeItem(storeKey);
            __classPrivateFieldGet(this, _iframe).hide();
            (_a = __classPrivateFieldGet(this, _icon)) === null || _a === void 0 ? void 0 : _a.hide();
            (_b = __classPrivateFieldGet(this, _icon)) === null || _b === void 0 ? void 0 : _b.deinit();
            __classPrivateFieldSet(this, _user, null);
        })
            .finally(() => __classPrivateFieldGet(this, _iframe).hide());
    }
    /**
     * Sends a transaction to be signed and broadcast
     *
     * @remarks
     * Only one set of operations can be sent at a time. If send is called while a previous is still pending,
     * an error will be thrown
     *
     * @param operations - A list of Tezos operations to sign and broadcast
     * @returns the operation hash resulting from broadcasting the operations
     */
    async send(operations, ui) {
        if (!this.initialized) {
            throw new Error("Cannot send: Embed Uninitialized");
        }
        // wait for card to close properly, if open
        if (!(ui === null || ui === void 0 ? void 0 : ui.silent)) {
            if (__classPrivateFieldGet(this, _iframe).isCard() && !__classPrivateFieldGet(this, _iframe).isHidden()) {
                await __classPrivateFieldGet(this, _messages).card(false);
            }
            __classPrivateFieldGet(this, _iframe).toFullScreen();
            __classPrivateFieldGet(this, _iframe).show();
        }
        return await __classPrivateFieldGet(this, _messages).operation(operations, ui)
            .then(res => res.opHash)
            .finally(() => {
            if (!(ui === null || ui === void 0 ? void 0 : ui.silent)) {
                __classPrivateFieldGet(this, _iframe).toCard();
                __classPrivateFieldGet(this, _iframe).hide();
            }
        });
    }
    /**
     * Tracks the status of an operation in the network
     *
     * @param opHash - The operation hash used to track the status of the operation
     * @returns the result of the transaction, either confirmation or rejection
     */
    async trackOperation(opHash) {
        if (!this.initialized) {
            throw new Error("Cannot track: Embed Uninitialized");
        }
        return await __classPrivateFieldGet(this, _messages).track(opHash);
    }
    /**
     * Signs a message with associated Kukai UI
     *
     * @param hexExpr - The hex encoded Micheline expression
     * @returns the detached signature made over the given message, encoded as baes58check
     */
    async signExpr(hexExpr, ui) {
        if (!this.initialized) {
            throw new Error("Cannot sign: Embed Uninitialized");
        }
        // wait for card to close properly, if open
        if (__classPrivateFieldGet(this, _iframe).isCard() && !__classPrivateFieldGet(this, _iframe).isHidden())
            await __classPrivateFieldGet(this, _messages).card(false);
        __classPrivateFieldGet(this, _iframe).toFullScreen();
        __classPrivateFieldGet(this, _iframe).show();
        return await __classPrivateFieldGet(this, _messages).signExpr(hexExpr, ui)
            .then(res => res.signature)
            .finally(() => {
            __classPrivateFieldGet(this, _iframe).hide();
            __classPrivateFieldGet(this, _iframe).toCard();
        });
    }
    /**
     * Accepts a challenge and returns an auth token and signature
     *
     * @param requestId - The ID to represent this instance of authentication
     * @param nonce - The challange string to sign
     * @returns the
     */
    async authenticate(requestId, nonce) {
        if (!this.initialized) {
            throw new Error("Cannot authenticate: Embed Uninitialized");
        }
        return await __classPrivateFieldGet(this, _messages).authenticate(requestId, nonce)
            .then(({ message, signature }) => ({ message, signature }));
    }
    async toggle() {
        if (__classPrivateFieldGet(this, _iframe).isHidden()) {
            __classPrivateFieldGet(this, _iframe).toCard();
            __classPrivateFieldGet(this, _iframe).show();
            __classPrivateFieldGet(this, _messages).card(true);
        }
        else {
            await __classPrivateFieldGet(this, _messages).card(false).then(() => {
                __classPrivateFieldGet(this, _iframe).hide();
            });
        }
    }
}
exports.KukaiEmbed = KukaiEmbed;
_iframe = new WeakMap(), _messages = new WeakMap(), _icon = new WeakMap(), _user = new WeakMap();
