"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _eventMap, _map, _queue, _single, _allowedOrigin, _enableLogging, _init, _card, _login, _operation, _track, _logout, _signExpr, _auth, _dismiss, _handle, _listener, _messageTarget, _eventSrc;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KukaiMessaging = void 0;
const types_1 = require("./types");
const util_1 = require("./util");
class Concurrent {
    constructor(map) {
        _eventMap.set(this, {});
        _map.set(this, void 0);
        __classPrivateFieldSet(this, _map, map);
    }
    async listen(id) {
        const { promise, deferred } = util_1.defer();
        __classPrivateFieldGet(this, _eventMap)[id] = deferred;
        return await promise;
    }
    handle(evt) {
        var _a;
        const id = __classPrivateFieldGet(this, _map).call(this, evt);
        (_a = __classPrivateFieldGet(this, _eventMap)[id]) === null || _a === void 0 ? void 0 : _a.resolve(evt);
        delete __classPrivateFieldGet(this, _eventMap)[id];
    }
}
_eventMap = new WeakMap(), _map = new WeakMap();
class Sequential {
    constructor() {
        _queue.set(this, []);
    }
    async listen() {
        const { promise, deferred } = util_1.defer();
        __classPrivateFieldGet(this, _queue).push(deferred);
        return await promise;
    }
    get length() {
        return __classPrivateFieldGet(this, _queue).length;
    }
    handle(evt) {
        var _a;
        (_a = __classPrivateFieldGet(this, _queue).shift()) === null || _a === void 0 ? void 0 : _a.resolve(evt);
    }
}
_queue = new WeakMap();
class Single {
    constructor() {
        _single.set(this, null);
    }
    async listen() {
        if (__classPrivateFieldGet(this, _single))
            throw new Error("OCCUPIED");
        else {
            const { promise, deferred } = util_1.defer();
            __classPrivateFieldSet(this, _single, deferred);
            return await promise;
        }
    }
    handle(evt) {
        var _a;
        (_a = __classPrivateFieldGet(this, _single)) === null || _a === void 0 ? void 0 : _a.resolve(evt);
        __classPrivateFieldSet(this, _single, null);
    }
}
_single = new WeakMap();
class MessageListener {
    constructor(allowedOrigin, enableLogging) {
        _allowedOrigin.set(this, void 0);
        _enableLogging.set(this, void 0);
        _init.set(this, new Single());
        _card.set(this, new Sequential());
        _login.set(this, new Sequential());
        _operation.set(this, new Single());
        _track.set(this, new Concurrent(res => res.opHash));
        _logout.set(this, new Sequential());
        _signExpr.set(this, new Sequential());
        _auth.set(this, new Sequential());
        _dismiss.set(this, new Sequential());
        _handle.set(this, (data) => {
            switch (data.type) {
                case types_1.ResponseTypes.cardResponse:
                    __classPrivateFieldGet(this, _card).handle(data);
                    break;
                case types_1.ResponseTypes.loginResponse:
                    __classPrivateFieldGet(this, _login).handle(data);
                    break;
                case types_1.ResponseTypes.operationResponse:
                    __classPrivateFieldGet(this, _operation).handle(data);
                    break;
                case types_1.ResponseTypes.trackResponse:
                    __classPrivateFieldGet(this, _track).handle(data);
                    break;
                case types_1.ResponseTypes.logoutResponse:
                    __classPrivateFieldGet(this, _logout).handle(data);
                    break;
                case types_1.ResponseTypes.signExprResponse:
                    __classPrivateFieldGet(this, _signExpr).handle(data);
                    break;
                case types_1.ResponseTypes.authResponse:
                    __classPrivateFieldGet(this, _auth).handle(data);
                    break;
                case types_1.ResponseTypes.initComplete:
                    __classPrivateFieldGet(this, _init).handle(data);
                    break;
                case types_1.ResponseTypes.dismissResponse:
                    __classPrivateFieldGet(this, _dismiss).handle(data);
            }
        });
        __classPrivateFieldSet(this, _allowedOrigin, allowedOrigin);
        __classPrivateFieldSet(this, _enableLogging, enableLogging);
    }
    async init() {
        return await __classPrivateFieldGet(this, _init).listen();
    }
    async login() {
        return await __classPrivateFieldGet(this, _login).listen();
    }
    async operation() {
        return await __classPrivateFieldGet(this, _operation).listen();
    }
    async track(id) {
        return await __classPrivateFieldGet(this, _track).listen(id);
    }
    async logout() {
        return await __classPrivateFieldGet(this, _logout).listen();
    }
    async signExpr() {
        return await __classPrivateFieldGet(this, _signExpr).listen();
    }
    async auth() {
        return await __classPrivateFieldGet(this, _auth).listen();
    }
    async card() {
        return await __classPrivateFieldGet(this, _card).listen();
    }
    async dismiss() {
        return await __classPrivateFieldGet(this, _dismiss).listen();
    }
    handleEvent(evt) {
        if (evt.type === 'message' && evt.origin === __classPrivateFieldGet(this, _allowedOrigin)) {
            if (__classPrivateFieldGet(this, _enableLogging)) {
                console.log(`Received ${evt.data} from ${evt.origin}`);
            }
            const data = JSON.parse(evt.data);
            __classPrivateFieldGet(this, _handle).call(this, data);
        }
        else {
            console.warn(evt.origin);
        }
    }
}
_allowedOrigin = new WeakMap(), _enableLogging = new WeakMap(), _init = new WeakMap(), _card = new WeakMap(), _login = new WeakMap(), _operation = new WeakMap(), _track = new WeakMap(), _logout = new WeakMap(), _signExpr = new WeakMap(), _auth = new WeakMap(), _dismiss = new WeakMap(), _handle = new WeakMap();
class KukaiMessaging {
    constructor(messageTarget, allowedOrigin, enableLogging) {
        _listener.set(this, void 0);
        _messageTarget.set(this, void 0);
        _eventSrc.set(this, null);
        __classPrivateFieldSet(this, _messageTarget, messageTarget);
        __classPrivateFieldSet(this, _listener, new MessageListener(allowedOrigin, enableLogging));
    }
    async init(eventSrc) {
        if (__classPrivateFieldGet(this, _eventSrc)) {
            throw new Error("Already Initialized");
        }
        else {
            __classPrivateFieldSet(this, _eventSrc, eventSrc);
            eventSrc.addEventListener('message', __classPrivateFieldGet(this, _listener));
            return await __classPrivateFieldGet(this, _listener).init().then(res => {
                if (res.failed)
                    throw new Error("Init Failed: " + res.error);
            });
        }
    }
    get isInit() {
        return !!__classPrivateFieldGet(this, _eventSrc);
    }
    deinit() {
        if (__classPrivateFieldGet(this, _eventSrc)) {
            __classPrivateFieldGet(this, _eventSrc).removeEventListener('message', __classPrivateFieldGet(this, _listener));
            __classPrivateFieldSet(this, _eventSrc, null);
        }
    }
    async card(show) {
        __classPrivateFieldGet(this, _messageTarget).request({ type: types_1.RequestTypes.cardRequest, show });
        return await __classPrivateFieldGet(this, _listener).card().then((res) => {
            if (res.failed)
                throw new Error("Card Failed: " + res.error);
            else
                return;
        });
    }
    async login(config) {
        __classPrivateFieldGet(this, _messageTarget).request({ type: types_1.RequestTypes.loginRequest, config });
        return await __classPrivateFieldGet(this, _listener).login().then(res => {
            if (res.failed)
                throw new Error("Login Failed: " + res.error);
            else
                return res;
        });
    }
    async operation(operations, ui) {
        __classPrivateFieldGet(this, _messageTarget).request({ type: types_1.RequestTypes.operationRequest, operations, ui });
        return await __classPrivateFieldGet(this, _listener).operation().then(res => {
            if (res.failed)
                throw new Error("Operation Failed: " + res.error);
            else
                return res;
        }).catch(e => {
            if (e.message === 'OCCUPIED')
                throw new Error('Cannot send: Operation in progress');
            else
                throw e;
        });
    }
    async track(opHash) {
        __classPrivateFieldGet(this, _messageTarget).request({ type: types_1.RequestTypes.trackRequest, opHash });
        return await __classPrivateFieldGet(this, _listener).track(opHash).then(res => {
            if (res.failed)
                throw new Error("Track Failed: " + res.error);
            else
                return res;
        });
    }
    async logout() {
        __classPrivateFieldGet(this, _messageTarget).request({ type: types_1.RequestTypes.logoutRequest });
        return await __classPrivateFieldGet(this, _listener).logout().then(res => {
            if (res.failed)
                throw new Error("Logout Failed: " + res.error);
            else
                return res;
        });
    }
    async signExpr(expr, ui) {
        __classPrivateFieldGet(this, _messageTarget).request({ type: types_1.RequestTypes.signExprRequest, expr, ui });
        return await __classPrivateFieldGet(this, _listener).signExpr().then(res => {
            if (res.failed)
                throw new Error("Signing Failed: " + res.error);
            else
                return res;
        });
    }
    async authenticate(id, nonce) {
        __classPrivateFieldGet(this, _messageTarget).request({ type: types_1.RequestTypes.authRequest, id, nonce });
        return await __classPrivateFieldGet(this, _listener).auth().then(res => {
            if (res.failed)
                throw new Error("Auth Failed: " + res.error);
            else
                return res;
        });
    }
    async dismiss() {
        __classPrivateFieldGet(this, _messageTarget).request({ type: types_1.RequestTypes.dismissRequest });
        return await __classPrivateFieldGet(this, _listener).dismiss().then((res) => {
            if (res.failed)
                throw new Error("Dismiss Failed: " + res.error);
            else
                return;
        });
    }
}
exports.KukaiMessaging = KukaiMessaging;
_listener = new WeakMap(), _messageTarget = new WeakMap(), _eventSrc = new WeakMap();
